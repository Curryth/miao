LeetCode

<script>


1. Two Sum

var twoSum = function(nums, target) {
    for (var i = 0;i < nums.length - 1; i++) {

        for (var j = i + 1; j < nums.length; j++) {
            if (nums[i] + nums[j] == target) {
                return [i, j]
            }
        }
    }
}

//我们不能一个一个去看所需要的那个数need在nums中存不存在（除非一遍一遍的比较need和数组中每个值的大小），即看nums[x] = need存不存在，
//但是可以把这个问题转化成need这个数在新数组a中的标号存不存在，即看a[need] 是否是undefined.
//而把nums[x] = need是否存在 ➡️a[need]是否为undefined，这样只需要循环一遍就可以找出需要的两个数
//公示的关键就是 a[nums[i]] = i ，即数组可以给任意下标赋值  
var twoSum = function(nums, target) {                    //这个方法没看懂，不会啊？？？？
    var a = []             // 本数组记录某个数载原数组中的第几位
    for (var i = 0； i < nums.length; i++) {
        var need = target - nums[i]
        if (a[need] !== undefined) {              
            return [a[need], i ]                  // need这个数在原数组的位置
           
        } esle {              // 到目前为止还没有记录need在原数组的位置
            a[nums[i]] = i      // 记录当前数在原数组中的位置
        }
        
    }
}

7. Reverse Integer

var reverse = function(x) {
    
};

167. Two Sum II - Input Array Is Sorted

var twoSum = function(nums, target) {
    var i = 0 
    var j = numbers.length - 1

    while (i < j) {                          //双指针，从首位两端同时逼近target值
        var sum = numbers[i] + numbers[j]
        if (sum > target) {
            j -- 
        }else if (sum < target) {
            i ++
        }else {
            return [i + 1 , j + 1]
        }
    }
}



26. Remove Duplicates from Sorted Array        // ？

var removeDuplicates = function(nums) {
    if (nums == 0) {                         // 双指针
        return 0
    }
    var nextPlace = 1                        // 从0和1的开始的区别
    for (var i = 1; i < nums.length; i++){
        if (nums[i] !== nums[i - 1]) {
              nums[nextPlace++]  = nums[i]
        }
    }
    return nextPlace

}

62. Unique Paths

var uniquePaths = function(m, n) {

}

66. Plus One

var plusOne = function(digits) {
    digits[digits.length - 1]++

    for (var i = digits.length - 1; i > 0; i-- ) {
        if (digits[i] == 10) {
            digits[i] =0
            digits[i - 1]++
        } else {
            return digits
        }
    }

    if (digits[0] == 10) {
        digits[0] = 0
        digits.unshift(1)
    }
    return digits
}

367
var isPerfectSqure = function (num) {
    
    var n = num / 2 
    isPerfectSqure =false
    
    if(num == 1) {
        return true
    }

    for (var i = 2; i <= n; i++){             //用二分法再做一遍
        if(i * i == num){
            isPerfectSqure = true
            return true 
        }
    } 

    if (!isPerfectSqure){
        return false 
    }   
}

258. Add Digits

var addDigits = function (num) {            //为什么求除以9的余数。一个数各个位上的数字模9之和就等于这个数模9的值

  if (num == 0) {
        return 0
    }
    if (num % 9 == 0) {
        return 9
    }
    
    return num % 9
        
}


var addDigits = function (num) {
  
    var sum = 0 
    while (num > 0) {
        var digit = num % 10
        sum += digit 
        num = (num - digit) / 10
    }
    
    if (sum < 10){
        return sum
    }else {
        return addDigits(sum)         //递归,并且需要这个运算结果，需要加个return返回结果
    }
    
}



263.Ugly Number

var isUgly = function(n) {             //除以2，3，5 直到得到的是1
    if (n < 1){
        return false
    }
    while ( n % 2 == 0){
        n = n / 2 
    }
    while ( n % 3 == 0){
        n = n / 3 
    }
    while ( n % 5 == 0){
        n = n / 5 
    }
    return n == 1

}



283

var moveZeroes = function(nums) {
    var a = []
    var n = nums.length
    var count = 0
    for (var i = 0; i < n; i++ ) {
        if (nums[i] == 0){
            count++
        }else { 
            a.push(nums[i])
        }
    }

    for (var j = 0; j < count; j++){
        a.push[0]
    }

    return a


}

function moveZeroes(nums[0,1,0,3,12]){
    var a = []
    var count = 0
    for (var i = 0; ; i++ ) {
        if (nums[i] == 0){
            count++
        }else { 
            a.push(nums[i])
        }
    }

    for (var j = 0; j < count; j++){
        a.push[0]
    }

    return a
    
}
326. Power of Three

var isPowerOfThree = function(n) {
    if (n == 0){
        return false
    }
    while ( n % 3 ==0) {
        n = n / 3
    }
    return n ==1
}

var isPowerOfThree = function(n) {



}
485
var findMaxConsecutiveOnes = function(nums) {

    var max = 0
    var c = 0

    for (var i = 0; i < nums.length; i++){
        if(nums[i] == 1){
            count++
            if (count > max) {
                max = count
            }
        }else{
            c = 0
        }
    }

    return max

}


412
var fizzBuzz = function(n){
    var answer = []

for (var i = 1; i <= n; i++){
    if(i % 3 == 0 && i % 5 == 0 ) {
        answer.push("FizzBuzz")
    }else if (i % 5 == 0) {
        answer.push("Buzz")
    }else if ( i % 3 == 0) {
        answer.push("Fizz")
    }else{
        
        answer.push('' + i)      //'' + i, 就把i转换成字符串
    }
   
    }
  return answer
}

202. Happy Number

var isHappy = function(n){

    var m = n
    var sum = 0
    
    do{
        while (m > 0) {
            var gewei = m % 10
            sum += gewei * gewei
            m = (m - gewei) / 10
        }
        m = sum
        sum = 0

      }while (m * m >= 10) 
          
      if (m == 1) {
            return true
      }else {
          return false
      }      

}

var isHappy = function(n){
    var appeared = []

    var sum = 0
    while (true) {
        var digit = n % 10
        sum += digit * digit
        n = (n - digit) / 10
    }
    if (sum == 1) {
        return true
    } else {
        for (var i = 0; i < appeared.length; i++) {
            if (sum == appeared[i]) {
                return false
            }
        }
        appeared.push(sum)
        n = sum
    }
  }
}

var isHappy = function(n) {
    var sum = 0
    while (n > 0) {
        var digit = n % 10
        sum += digit * digit
        n = (n - digit) / 10
    }

    if (sum == 1) {
        return true
    } else if (sum == 4) {
        return false
    } 

    return isHappy(sum)

}

977. 有序数组的平方

var sortedSquares = function(nums) {
  
  var a = []

  for (var i = 0; i < nums.length; i++) {
      a.push(nums[i] * nums[i])
  }
  
  for (var i = 0; i < nums.length; i++) {
      for (var j = i + 1; j < nums.length; j++) {
          if (a[j] <= a[i]) {
              var m = a[i]
              a[i] = a[j]
              a[j] = m
          }
      }
  } 
  return a

};



var distributeCandies = function(candyType) {
    n = candyType.length
    var count = 1
    var a = []

    a.push(candyType[0])

    for (var i = 1; i < n; i++) {
        var isNewcandyType = true
 
        for (var j = 0 ; j < a.length; j++) {
            if (candyType[i] == a[j]) {
                isNewcandyType = false
                break
            }
        }

        if (isNewcandyType) {
            count++
            a.push(candyType[i])
        }

    }

    if (n / 2 >= count) {
        return count
    }else {
        return n / 2
    }

};



35. 搜索插入位置

var searchInsert = function(nums, target) {
    for (var i = 0; i < nums.length; i++) {
        if (target == nums[i]) {
            return i
        } else {
            if(target < nums[0]) {
                return 0
            } else if (target > nums[nums.length - 1]) {
                return nums.length
            }else {
                for (var j = 0; j < nums.length; j++ ) {
                    if (target > nums[j] && target <nums[j + 1]) {
                        return j + 1
                    }
                }
            } 
        } 
    }
};

504. 七进制数

var convertToBase7 = function(num) {
    var result = ''
    var number = num

    if (number == 0) {
        return '0'
    }
    if (number < 0) {
        number = - number
    }

    while(number > 0) {
        var digit = number % 7
        result = String(digit) + result
        number = (number - digit) / 7
    }
    


    if (num > 0) {
    return result
    }else {
        return result = '-' + result
    }

};

var countPrimes = function(n) {
  var knownPrime = 

  var countPrimes = function (n) {
      
  }
  

  function isPrime(n) { 
      
  }



};



var countPrimes = function(n) {
    var isPrime = Array(n).fill(true)

    for (var i = 2; i * i < n; i++) {
        if (isPrime[i]) {
            for (var j = 2 * i; j < n; j += i) {
                isPrime[j] = false
            }
        }
    }

    var count = 0

    for (var i = 2; i < isPrime.length; i++) {
        if (isPrime[i]) {
            count++
        }
    }
    return count

}

338. 比特位计数

var countBits = function(n) {
    var result = [0]

    var sub = 1
    var subTimes = 0

    for (var i = 1; i <= n; i++) {
        result[i] = result [i - sub] + 1
        subTimes++
        if (subTimes == sub) {
            sub = sub * 2
            subTimes = 0
        }
    } 
    return result
};

50. Pow(x, n)

    var myPow = function(x, n) {

    if (n % 2 == 0) {
        return 1
    } 
    if (n % 2 == 0) {
        var t = myPow((x, n / 2), 2)
    } else {
        return myPow(myPow(x, Math.floor(n / 2)), 2) * x
    }

    };


338. 比特位计数

var countBits = function(n) {
    var result = [0]

    var sub = 1
    var subTimes = 0

    for (var i = 1; i <= n; i++) {
        result[i] = result [i - sub] + 1
        subTimes++
        if (subTimes == sub) {
            sub = sub * 2
            subTimes = 0
        }
    } 
    return result
}

// 位运算中的与运算

var countBits = function(n) {
    var result = [0]

    for (var i = 1; i <= n; i++) {
        result[i] = result [i & （i - 1）] + 1

    } 
    return result
}

50. Pow(x, n)

var myPow = function(x, n) {
    if（ n < 0) {
        return 1 / myPow(x, -n)
    }

    var start = x
    var result = 1

    while (n > 0) {
        var digit = n % 2
        if (digit == 1) {
            result *= start
        }
        start = start * start
        n = (n - digit) / 2
    }

    return result
};


count - Primes 

var knownPrimes = [2, 3, 5, 7]

var countPrimes = function (n) {
    if (n < 2) {
        return 0
    }

    var count = 1
    for (var i = 3; i < n; i += 2) {
        if (isPrimes(i)) {
            if (i > knownPrimes[knownPrimes.length - 1]) {
                knownPrimes.push(i)
            }
        }
    }
    
}

function isPrime(n) {
    if (n < 2) {
        return false
    }
    var sn = Math.sqrt(n)
    var prime 
    for (var i = 0; (prime = knownPrimes[i]) <= sn; i++) {
        if (n % prime == 0) {
                return false
            }
        }
    }
    
}


var countPrimes = function (n) {

    var isPrime = Array(n).fill(true)    //先假设所有数都是素数

    for (var i = 2; i * i < n; i++) {
        if (isPrime[i]) {
            for (var j = 2 * i; j < n; j += i) {
                isPrime[j] = false
            }
        }
    }

    var count = 0

    for (var i = 2; i < isPrime.length; i++) {
        if (isPrime[i]) {
            count++
        }

    }
    return count

}



42.接雨水

    var trap = function(height) {
        var len = height.length
        for () {
            var leftMaxHeight = 0
            for (var j = i - 1; j >= 0; j--)
        }
    }
    var rightMaxHeight = 0
    for (var k = i + 1; knownPrimes < len; k++) {
        if (height[k] > rightMaxHeight) {
            rightMaxHeight = height[k]
        }
    }

    var waterHeight = max.min(leftMaxHeight,rightMaxHeight)




  var leftTillMax = [] //




415.字符串相加

3. 无重复字符的最长子串

var lengthOfLongestSubstring = function(s) {
    var map = {}  // 记录窗口范围内每个字符出现的次数
    var i = 0
    var j = 0
    var max = 0

    while (j < s.length) {
        var char = s[j]
        if (char in map) {
            map[char]++
            if (map[char] == 2) {
                while (i < j) {
                    var c = s[i++]
                    map[c]--
                    if (map[c] == 1) {  // 一旦有一个字符去掉后次数变为1，则结束
                        break
                    }
                }
            } 
        } else {
            map[char] = 1
        }
        if (j - i + 1> max) {
            max = j - i + 1
        }
        j++
    }

 return max 

}


387. 字符串中的第一个唯一字符

var firstUniqChar = function(s) {
    var map = {}

     for (var i = 0; i < s.length; i++) {
        var char = s[i]
        if (char in map) {
            map[char]++
        } else {
            map[char] = 1
        }
    }

    for (var i = 0; i < s.length; i++) {
        var char = s[i]
        if (map[char] == 1) {
            return i
        }
    }

    return -1

}

// 面试题，大整数相加，
//对于大整数，是指超过规定类型的整数，它一般的存储类型为字符串类型char。
//在JS中，需要将字符串中的每一位字符利用parseInt()转成整数，再做加减，否则最后的结果是字符串的连接
415. 字符串相加   

var addStrings = function(num1, num2){
    var l1 = num1.length
    var l2 = num2.length
    
    var r = ''
    var carry = 0
    for (var i = l1 - 1, j = l2 - 1; i >= 0 || j >= 0; i--, j--) {
        var a = Number(num1[i] ?? 0)
        var b = Number(num2[j] ?? 0)
        var s = a + b + carry
        r = s % 10 + r
        carry = s > 9 ? 1 : 0

    }
    if (carry) {
        return carry + r
    } else {
        return r
    }
}

43. 字符串相乘      // 写的有点牛逼

var multiply = function(num1, num2) {
    if (num2.length > num1.length) {    // 拿
        var t = num1
        num1 = num2
        num2 = t
    }

    var multipies = ['0']  // num1的0倍到9倍
    var start = num1
    for (var i = 1; i < 10; i++) {
        multipies.push(start)
        start = addStrings(start, num1)
    }

    var result = '0'

    for (var i = num2.length - 1, padZeros = 0; i >= 0; i--, padZeros++) {
        var a = num2[i]
        var times = multipies[a] + '0'.repeat(padZeros)
        result = addStrings(result, times)
    }
    return result
}





53. 最大子数组和

//解法1

var maxSubArray = function(nums) {

var ThisSum = 0
var MaxSum = 0   // MaxSum不能为-Infinity,因为MaxSum = 0可以防止第一个数是负数的时候把负数加进来
var max = -Infinity

for (var i = 0; i < nums.length; i++) {
    ThisSum += nums[i]

    if (nums[i] > max) {
        max = nums[i]
    }

    if (ThisSum > MaxSum) {
        MaxSum = ThisSum
    } else if (ThisSum < 0) {
        ThisSum = 0
    }
}

if (MaxSum == 0) {
    return max
} else {
    return MaxSum
}

};



var maxSubArray = function(nums) {
    var mid = nums.length >> 1
    var left = nums.slice(0,mid)
    var right = nums.slice(mid)

    var leftMax = maxSubArray(left)
    var rightMax = maxSubArray(right)

    var leftSpinMax = 0
    var sum = 0

    for (var i = mid - 1; i >= 0; i --) {
        sum += nums[i]
        if (sum > leftSpinMax) {
            leftSpinMax = sum
        } 
    }

    var rightSpinMax = 0
    var sum = 0

    for (var i = mid ; i < nums.length; i ++) {
        sum += nums[i]
        if (sum > rightSpinMax) {
            rightSpinMax = sum
        } 
    }

    var spinMax = leftSpinMax + rightSpinMax

    return Math.max(spinMax, leftMax, rightMax)


    
};


7. 整数反转

var reverse = function(x) {

var min = Math.pow(-2, 31)          // 避免反转后的数溢出
var max = Math.pow(2, 31) - 1       // 
var sign = Math.sign(x)             // 保留符号位
var m = Math.abs(x)
var sum = 0

while (m > 0) {
    var d = m % 10
    sum = sum * 10 + d
    m = (m - d) / 10
}

var reverse = sign * sum

if (reverse > max ) {                // 溢出后返回值为0
    return 0
} else if (reverse < min) {
    return 0
} else {
    return reverse
}

};


13. 罗马数字转整数

var romanToInt = function(s) {
    var obj = {
        "I":              1,
        "V":              5,
        "X":             10,
        "L":             50,
        "C":             100,
        "D":             500,
        "M":             1000,
    };
    var result = 0
    for (var i = 0; i < s.length; i++) {
        var front = s[i] 
        var back = s[i + 1]
        
        if (obj[back] > obj[front]) {  // 这里用obj.back和front就输出为NAN
            result -= obj[front]
        } else {
            result += obj[front]
        }
    }

    return result

};

977. 有序数组的平方

// 解法1，sort排序

    var sortedSquares = function(nums) {
        var array = []

        for(var i = 0; i < nums.length; i++) {
            array[i] = nums[i] * nums[i]
        }

        array.sort((a, b) => a - b)       // sort中，a - b 代表升序。b - a 则为降序
        return array
    
    };

// 解法2，双指针



var firstUniqChar = function(s) {
    var map = {}

    for (var i = 0;) {
        var char = s[i]
        if (char in map) {
            map[char]++
        } else {
            map[char] = 1
        }
    }
    for () {
        var char = map []
    }
}




var lengthOfLongestSubstring = function(s) {
    for (var start = 0; start < s.length; start++) {
        for (var end = start + 1; end <= s.length) {
            var part = s.slice(start, end) 
            if (part 没有重复) {
                max = math.max(part.length, max)
            }
        }
    }
    return  max  
}

var lengthOfLongestSubstring = function(s) {
    var map = {}    // 记录滑动窗口范围内每个字符出现的次数
    var i = 0
    var j = -1
    var max = 0

    while (j < s.length) {
        j++
        var char = s[j] 
        if (char in map) {
            map[char]++
            if (map[char] == 2) {
                while (xxx) {
                    var c = s[i++]
                    map[c]--
                    if (map[c] == 1) {  // 一旦有一个符号去掉后次数变为1，则结束循环
                        break
                    }

                }

            }
        } else {
            map[char] = 1
            if (j - 1 + 1 > max) {
                max = j - 1 + 1
            }
        }
    }
}



237. 删除链表中的节点

    var deleteNode = function(node) {

        node.val = node.next.val          // 无法直接删除这个结点，但是可以把下个结点的值覆盖到要删除的这个结点上
        node.next = node.next.next

    };






141. 环形链表

var hasCycle = function(head) {
    var map = []
    while (head) {
        if (map.includes(head)) {
            return true
        }
        map.push(head)
        head = head.next
    }
    return false 
};

var hasCycle = function(head) {
    var slow = head
    var fast = head

    while (fast && fat.next.next) {
        slow = head.next
        fast = head.next.next
        if (fast = slow)
        return true
        break
    }

    return false


}

206. 反转链表

    var reverseList = function(head) {
        var pre = null         // 设置一个前置fake结点
        var cur = head         // 设置当前结点cur为head

        while (cur) {
            var tmp = cur.next     // 用中间值tmp保存原有的下个结点的位置指向
            cur.next = pre         // cur的指针调转方向，指向pre
            
            pre = cur    // pre 和cur都下移一位开始重复循环，直至cur指向原本链表末尾的null
            cur = tmp
        }

        return pre     // 返回新的头结点，pre

    };


    var reverseList = function(head) {
        if (!head || !head.next) {          // 如果只有一个结点或为空
            return head
        }
        
        var nodes = []

        while (head) {
            nodes.push(head)
            head = head.next
        }

        nodes.reverse()

        for (var i = 0; i < nodes.length - 1; i++) {
            node[i].next = node[i + 1]
        }
        nodes[i].next = null

        return nodes[0]

    }


19. 删除链表的倒数第 N 个结点

    var removeNthFromEnd = function(head, n) {

        var node = head
        var count = 0

        while(node) {
            node = node.next
            count++
        }

        var step = count - n - 1

        if (step == -1) {
            return head.next
        }

        node = head
        while(step > 0) {
            node = node.next
            step--
        }

        node.next = node.next.next
        return head

    };


    var removeNthFromEnd = function(head, n) {
        var p = head
        var count
    }


    21. 合并两个有序链表

    var mergeTwoLists = function(list1, list2) {

        var cur1 = list1
        var cur2 = list2

        var newList = new ListNode(0)          // 创造一个新链表？？还有没有其他方式创建
        var node = newList

        while (cur1 && cur2) {
            if (cur1.val < cur2.val) {
                node.next = cur1
                cur1 = cur1.next
            } else {
                node.next = cur2
                cur2 = cur2.next
            }
            node = node.next               // node结点下移一位，构成循环的一环
        }

        if (cur1 && cur2 == null) {          // 如果其中一个链表为null，则只需要加上另外一个链表
            node.next = cur1
        }
        if (cur2 && cur1 == null) {
            node.next = cur2
        }

        return newList.next

    };


    var mergeTwoLists = function(list1, list2) {

        var dummy = new ListNode(0)             // 最后要输出头结点dummy.next，所以要用将dummy存起来
        var p = dummy

        while (list1 && list2) {
            if (list1.val < list2.val) {
                p.next = list1
                list1 = list1.next
            } else {
                p.next = list2
                list2 = list2.next
            }
            p = p.next
        }

        p.next = list1 || list 2

        return dummy.next

    };


142. 环形链表 II

    var detectCycle = function(head) {

        var map = new Set()

        while (head !== null) {
            if (map.has(head)) {
                return head
            } else {
                map.add(head)
            }
            head = head.next
        }

        return null

    };






    24. 两两交换链表中的节点

    var swapPairs = function(head) {
        var swapPairs = function(head) {

        var dummy = new ListNode(0)
        dummy.next = head
        var prev = dummy

        while (head && head.next) {
            var temp = head.next
            
            head.next = temp.next
            prev.next = temp
            temp.next = head

            prev = head
            head = head.next

        }
        return dummy.next
    };

    }


215. 数组中的第K个最大元素

// swap函数最好放在外面，不然递归的时候会执行若干次
function swap(ary, i, j) {
        var temp = ary[i]
        ary[i] = ary[j]
        ary[j] = temp
}

var findKthLargest = function(nums, k, start = 0, end = nums.length - 1) {
    if (end - start == 0) {
        return nums[start]
    }

    var pivotIdx = Math.floor( Math.random() * (end - start + 1) + start )
    var pivot = nums[pivotIdx]

    swap(nums, pivotIdx, )

    var i = start

    for (var j = start; j < end; j++) {
        if (nums[j] > pivot) {
            swap (nums, i++, j)
        }
    }
    swap (nums, i, end) 
    
    if (i == k - 1) {
        return nums[i]
    }
    if (i > k - 1) {
       return findKthLargest(nums, k, start, i - 1)
    } else {
       return findKthLargest(nums, k, i + 1, end)
    }

} 
最后一部分写成这样也可以
    if (i == k - 1) {
        return nums[i]
    }
    if (i > k - 1) {
       findKthLargest(nums, k, start, i - 1)
    } else {
       findKthLargest(nums, k, i + 1, end)
    }
    return nums[k - 1]
    
我最开始愚蠢的写法
var findKthLargest = function(nums, k) {
    qSort(nums,start = 0, end = nums.length - 1, k)
    return nums[k - 1]
};

    function swap(ary, i, j) {
    var temp = ary[i]
    ary[i] =ary[j]
    ary[j] = temp
     }

    function qSort(nums, start = 0, end = nums.length - 1, k) {
        var pivotIdx = Math.floor(Math.random() * (end - start + 1) + start)
        var pivot = nums[pivotIdx]

        swap(nums, pivotIdx, end)
        
        var i = start
        for (var j = i; j < end; j++) {
            if (nums[j] > pivot) {
                swap(nums, i, j)
                i++
            }
        }
        swap(nums, i, end)
        if (i == k - 1) {
            return nums[i]
        } else if (i < k - 1) { 
            qSort(nums, i + 1, end, k)
        } else if (i > k - 1) {
            qSort(nums, start, i - 1, k)
        }
        return nums
    }

100. 相同的树

var isSameTree = function(p, q) {
    if (p == null && q == null) {
        return true
    }
    if (p == null && q != null || p != null && q == null) {
        return false
    }
    if (p.val !== q.val) {
        return false
    }

    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)

};
// 精简版。二叉树中左右没有重叠，运用递归不会像斐波那契数列一样存在大量重复计算的情况。
var isSameTree = function(p, q) {
    if (!p && !q) {
        return true
    }
    if (!p && q || p && !q) {
        return false
    }
    return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right)

}

104. 二叉树的最大深度

var maxDepth = function(root) {
    if (root == null)  {
        return 0
    }
    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right))
}


111. 二叉树的最小深度

var minDepth = function(root) {
    if (root == null) {
        return 0
    }
    if (root.left == null && root.right != null) {
        return 1 + minDepth(root.right)
    }
    if (root.right == null && root.left != null) {
        return 1 + minDepth(root.left)
    }
    return Math.min(minDepth(root.left), minDepth(root.right)) + 1

}

var minDepth = function(root) {
    if (!root) {
        return 0
    }
    if (!root.left && root.right) {
        return 1 + minDepth(root.right)
    }
    if (!root.right&& root.left) {
        return 1 + minDepth(root.left)
    }
    return 1 + Math.min(minDepth(root.left), minDepth(root.right))

}

226. 翻转二叉树

var invertTree = function(root) {
    if (!root) {
        return root
    }
    invertTree(root.left)   // 用递归把左子树翻转
    invertTree(root.right)   // 再把右子树翻转

    const temp = root.right   // 把左右子树换位置，整个翻转过程完成
    root.right = root.left    //
    root.left = temp

    return root
}

617. 合并二叉树

var mergeTrees = function(root1, root2) {
    if (!root1) {
        return root2
    }
    if (!root2) {
        return root1
    }

     root1.val += root2.val

    root1.left = mergeTrees(root1.left, root2.left)
    root1.right = mergeTrees(root1.right, root2.right)

    return root1

};


144. 二叉树的前序遍历

非递归写法，递归写法面试不给过的
二叉树非递归遍历的逻辑要搞清楚
一般面试都是问先序或者中序遍历的非递归写法，不问后序的

var preorderTraversal = function(root) {
    var result = []

    var nodes = []
    var p = root
    
    while(true) {
        while (p) {
            nodes.push(p)
            result.push(p.val)
            p = p.left
        }
    }

    while (nodes.length) {
        p = nodes.pop()
        if (p.right) {
            p = p.right
            break
        }
     }
    return result
}



var preorderTraversal = function(root, result = []) {
    
    if (root == null) {
        return result
    } 
    
    result.push(root.val)
    preorderTraversal(root.left,result)
    preorderTraversal(root.right,result)  

    return result

}

 
var preorderTraversal = function(root) {
    
    var result = []

    function preOrder(root) {
        if (root == null) {
            return result
        } 
        
        result.push(root.val)     // 先根结点，再左子结点，右子结点。
        preOrder(root.left)
        preOrder(root.right)  
    }
    preOrder(root)   // 写了个preOrder函数要调用才能有输出结果
    return result

}


114. 二叉树展开为链表

var flatten = function(root) {
    if (root == null) {
        return []
    }

    flatten(root.left)      // 先用递归把左右子树展平
    flatten(root.right)

    var left = root.left    // 把左右子树先保存下来
    var right = root.right

    root.left = null        // 把左子树断掉清空，接到右子树原本的位置
    root.right = left

    while (root.right != null) {     // 把左子树的末端变成新的根结点
        root = root.right            // 把原本的右子树接到左子树下面
    }
    root.right = right

    return right
}

105. 从前序与中序遍历序列构造二叉树

var buildTree = function(preorder, inorder) {
    if (!preorder.length || !inorder.length) {
        return null
    }

    var node = new TreeNode(preorder[0])

    var index = inorder.indexOf(preorder.shift())  
    // 将preorder中每个结点可能有的子树，依次从inorder中分离出来

    node.left = buildTree(preorder, inorder.slice(0, index))
    node.right = buildTree(preorder, inorder.slice(index + 1))

    return node
}

106. 从中序与后序遍历序列构造二叉树

var buildTree = function(inorder, postorder) {
    if (!inorder.length || !postorder.length) {
        return null
    }

    var node = new TreeNode(postorder.pop())

    var index = inorder.indexOf(node.val) 
     

    node.left = buildTree(inorder.slice(0, index), postorder.slice(0, index))
    node.right = buildTree(inorder.slice(index + 1), postorder.slice(index))
    // inorder index两侧为 左子树 + 右子树
    // inorder的左子树与postorder的左子树，inorder的右子树与postorder的右子树，分别递归

    return node
}

老谢解法

var buildTree = function(inorder, postorder) {
    if (inorder.length == 0) {     
        return null
    }

    var root = new TreeNode(postorder[postorder.length - 1])
    var rootIdxInorder = inorder.indexOf(root.val)
    // 找到根结点在中序遍历中的下标位置 
     
    var leftInorder = inorder.slice(0, rootIdxInorder)
    var rightInorder = inorder.slice(rootIdxInorder + 1)
    // 中序遍历中，根结点左侧为左子树，右侧为右子树

    var leftPostorder = postorder.slice(0, rootIdxInorder)
    var rightPostorder = postorder.slice(rootIdxInorder, postorder.length - 1)
    // 后序遍历中，rootIdxInorder左侧为其左子树，右侧为其右子树
    // 其实为什么在后续遍历数组中，以中序遍历数组中根结点的下标位置来切分，还是有点需要观察得出的
    // 到postorder.length - 1 的位置是不包含根结点的
    root.left = buildTree(leftInorder, leftPostorder)
    root.right = buildTree(rightInorder, rightPostorder)

    return root
}


889. 根据前序和后序遍历构造二叉树

var constructFromPrePost = function(preorder, postorder) {
    if (!preorder.length || !postorder.length) {
        return null
    }

    var root = new TreeNode(preorder[0])
    var index = postorder.indexOf(preorder[1]) 
    // 左子树根结点在post中的位置即是post中左右子树的分割线

    var leftPreOrder = preorder.slice(1, index + 2)
    var rightPreOrder = preorder.slice(index + 2)
    // 先序遍历中左子树和右子树的分界线要分清楚。

    var leftPostOrder = postorder.slice(0, index + 1)
    var rightPostOrder = postorder.slice(index + 1, postorder.length -1)
    //slice的边界条件要搞清

    root.left = constructFromPrePost(leftPreOrder, leftPostOrder)
    root.right = constructFromPrePost(rightPreOrder, rightPostOrder)

    return root

}

102. 二叉树的层序遍历

var levelOrder = function(root) {
    if (root == null) {
        return null
    }
    var result = []

    var row = [root]

    while(row.length) {
        var rowVals = []    // 记住存储当前行的值
        var nextRow = []    // 存储下一行的结点

        for (var i = 0; i < row.length; i++) {
            var node = row[i]   // 取出当前行的当前结点
            rowVals.push(node.val)   // 将结点的值存入数组
            if (nodes.left) {  // 如果左子结点存在，则将其放入下一行结点的数组
                nextRow.push(node.left)
            }
            if (nodes.right) {
                nextRow.push(node.right)
            } 
        }
        result.push( rowVals )  // 把该行结点的值组成的数组放入结果数组
        row = nextRow     // 下一行称为当前行
    }

}


606. 根据二叉树创建字符串

var tree2str = function(root) {
    if (!root) {
        return ''
    }
    if (!root.left && !root.right) {
        return '' + root.val
    }
    if (!root.left) {
        return root.val + '(' + tree2str(root.right) + ')'
    }
    if (!root.right) {
        return root.val + '(' + 
    }
   
}



98.验证二叉搜索树

var isValidBST = function(root) {
    var prevVal = -Infinity
    inorderTraverse(root, val => {
      if (val <= prevVal) {
          isBST = false
      }
      prevVal = val
    })
    return isBST
}

function inorderTraverse(root, action) {
    if (root) {
        if (inorderTraverse(root.left, action) === false) {
            return false // 返回false告诉上层调用者不用遍历了
        }
        if (  action(root.val) === false ) {
            return
        }
        if (inorderTraverse(root.right, action) === false) {
            return false
        }
    }
}

108. 将有序数组转换为二叉搜索树

var sortedArrayToBST = function(nums) {
    if (nums.length === 0) {
        
    }
}


225. 用队列实现栈
    class MyStack {
        queue1 = []
        queue2 = []

        push(x) {
            this.queue2.push(x)
            while(this.queue1.length) {
                this.queue2.push(this.queue1.shift())
            }
            [this.queue1, this.queue2] =[this.queue2, this.queue1]
        }
        pop() {
            return this.queue1.shift()
        }
        top() {
            return this.queue1[0]
        }
        empty() {
            return !this.queue1.length
        }
    }



232. 用栈实现队列

    function MyQueue () {
        this.inStack = []
        this.outStack = []
    }

    MyQueue.prototype = {
        push(x) {
            this.inStack.push(x)
        }, 
        moveStack() {
            while (!this.outStack.length) {
                while (this.inStack.length) {
                    this.outStack.push(this.inStack.pop())
                }
            }
        },

        pop() {
            this.moveStack()
            return this.outStack.pop()
        },

        peek() {
            this.moveStack()
            return this.outStack[this.outStack.length - 1]
        },

        empty() {
            return !this.inStack.length && !this.outStack.length
        }
    }


    706. 设计哈希映射
    
    class MyHashMap {
    constructor() {
      this.maps = Array(32).fill(null)
      this._size = 0
    }
   
    hashCode(key) {
      if (typeof key == 'number') {
        key = 'N-' + key
      } else if (typeof key == 'string') {
        key = 'S-' + key
      } else if (typeof key == 'boolean') {
        key = 'B-' + key
      } else if (key == null) {
        key = 'NIL-' + key
      } else {
        if ('my_hashtable_objectId' in key) {
          key = key.my_hashtable_objectId
        } else {
          key = key.my_hashtable_objectId = 'O-' + Stirng(id++)
        }
      }
      var hash = 131313131
      var seed = 131
      for (var i = 0; i < key.length; i++) {
        hash = (((hash * seed) >>> 0) + key.charCodeAt(i)) >>> 0  // ？位运算，不带符号向右移0位，避免溢出的情况
      }
      return hash % this.maps.length
    }

    put(key,val) {
      var idx = this.hashCode(key)
      var p = this.maps[idx]
        while (p) {          // 遍历p链表,寻找目标key值的p结点，找到了就将p.val覆盖为新val
          if (p.key === key) {    
            p.val = val
            return this
          }
          p = p.next   
        }
      this.maps[idx] = {    // 如果找到最后都没有符合要求的结点，那就在哈希表上某个位置创造头结点存放这个对象
        key: key,
        val: val,
        next: this.maps[idx]
      } 
      this._size++
      if (this._size / this.maps.length > 0.75) {  // 当空间被占据到75%以上的时候
        this.扩容()
      }
      return this
    }
   
    扩容() {
      var prevMaps = this.maps         // 把原来数组的值全都取出来
      this.maps = new Array(this.maps.length * 2).fill(null)   // 原数组扩容两倍
      this._size = 0               // 扩容后清空size 
      for (var list of prevMaps) {
        var p = list
        while (p) {
          var key = p.key
          var val = p.val
          this.put(key, val)    // this不是prevMaps的，this是hashTable
          p = p.next
        }
      }
    }
    
    缩容() {
      if (this.maps.length <= 32) {
        return
      }
      var prevMaps = this.maps         // 把原来数组的值全都取出来
      this.maps = new Array(this.maps.length / 2).fill(null)
      this._size = 0               // 扩容后清空size 
      for (var list of prevMaps) {
        var p = list
        while (p) {
          var key = p.key
          var val = p.val
          this.put(key, val)    // this不是prevMaps的，this是hashTable
          p = p.next
        }
      }
    }
    
    get(key) {
      var idx = this.hashCode(key)
      var p = this.maps[idx]
      while (p) {
        if (p.key === key) {
          return p.val
        }
        p = p.next
      }
      return - 1
    }
    
    has(key) {
      var idx = this.hashCode(key)
      var p = this.maps[idx]
      while (p) {
        if (p.key === key) {
          return true
        }
        p = p.next
      }
      return false
    }
    
    remove(key) {
      var idx = this.hashCode(key)
      var p = this.maps[idx]
      if (!p) {
          return
      }
      if (p.key === key) {        // 如果头结点就是要删除的对象，则删除头结点
          this.maps[idx] = p.next
          this._size--
          if (this._size / this.maps.length < 0.2) {
            this.缩容
          }
          return this
      }
      while (p.next) {            // 否则就遍历链表继续找要删除的那个结点
        if (p.next.key == key) {
          p.next = p.next.next
          this._size--
          if (this._size / this.maps.length < 0.2) {
            this.缩容
          }
          break
        }
        p = p.next
      }
      return this
    }
    
    clear() {
      this.maps = Array(32).fill(null)
      this._size = 0
      return this
    }
  }


</script>    